[33mcommit a444c57348338a4c3c1704a3fd041801b9e65f79[m[33m ([m[1;32mtmp[m[33m)[m
Author: christophe le cam <c_lecam@yahoo.fr>
Date:   Sun Jan 12 14:52:11 2025 +0100

    tmp

[1mdiff --git a/src/entity/engine/actor/engine_dispatcher/handler_engine.rs b/src/entity/engine/actor/engine_dispatcher/handler_engine.rs[m
[1mindex bca0d01..23b8107 100644[m
[1m--- a/src/entity/engine/actor/engine_dispatcher/handler_engine.rs[m
[1m+++ b/src/entity/engine/actor/engine_dispatcher/handler_engine.rs[m
[36m@@ -1,4 +1,5 @@[m
 use std::sync::Arc;[m
[32m+[m[32muse std::sync::atomic::{AtomicBool, Ordering};[m
 [m
 use actix::{Arbiter, AsyncContext, Handler, Message};[m
 [m
[36m@@ -250,22 +251,25 @@[m [mimpl Handler<EngineInit> for EngineDispatcher {[m
     type Result = ();[m
 [m
     fn handle(&mut self, _msg: EngineInit, _ctx: &mut Self::Context) -> Self::Result {[m
[31m-        let engine_ref = Arc::clone(&self.engine); // Clone the Arc[m
[31m-        // start non blocking task find_best_move[m
[32m+[m[32m        let engine_ref = Arc::clone(&self.engine);[m
[32m+[m[32m        let stop_flag = Arc::new(AtomicBool::new(false));[m
[32m+[m[32m        let stop_flag_clone = Arc::clone(&stop_flag);[m
[32m+[m[41m        [m
         let self_actor = self.self_actor_opt.as_ref().unwrap().clone();[m
         let stat_actor_opt = self.stat_actor_opt.as_ref().cloned();[m
         let game_clone = self.game_opt.as_ref().unwrap().clone();[m
         tracing::debug!("Calling engine");[m
         let thread_find_best_move = actix_rt::task::spawn_blocking(move || {[m
[31m-            if let Ok(engine) = engine_ref.lock() {                                                [m
[32m+[m[32m            if let Ok(mut engine) = engine_ref.lock() {[m
                 tracing::debug!("Start computing");[m
[31m-                engine.find_best_move(self_actor, stat_actor_opt, game_clone);[m
[31m-                tracing::debug!("End computing");            [m
[31m-            }  else {[m
[32m+[m[32m                engine.find_best_move_with_stop(self_actor, stat_actor_opt, game_clone, stop_flag_clone);[m
[32m+[m[32m                tracing::debug!("End computing");[m
[32m+[m[32m            } else {[m
                 tracing::error!("Cannot acquire mutex for Engine in Handle<EngineInit>");[m
             }[m
         });[m
         self.thread_find_best_move_opt = Some(thread_find_best_move);[m
[32m+[m[32m        self.stop_flag = stop_flag;[m
     }[m
 }[m
 [m
[36m@@ -279,17 +283,21 @@[m [mimpl Handler<TimeoutCheck> for EngineDispatcher {[m
     fn handle(&mut self, msg: TimeoutCheck, _ctx: &mut Self::Context) -> Self::Result {[m
         tracing::debug!("Timeout check triggered");[m
         if let Some(game_manager) = &self.game_manager_actor_opt {[m
[31m-            // Use the game manager to get the best move[m
             if let Some(uci_caller) = &self.uci_caller_opt {[m
[32m+[m[32m                let stop_flag = Arc::clone(&self.stop_flag);[m
                 let game_manager_clone = game_manager.clone();[m
                 let uci_caller_clone = uci_caller.clone();[m
                 let max_time = msg.0;[m
[32m+[m[41m                [m
                 actix::Arbiter::spawn([m
[31m-                    &Arbiter::new(),[m
[32m+[m[32m                    &actix::Arbiter::new(),[m
                     async move {[m
                     tracing::debug!("Sleeping {:?}", max_time);[m
                     tokio::time::sleep(max_time).await;[m
                     tracing::debug!("End Sleeping.");[m
[32m+[m[32m                    tracing::debug!("Stopping engine");[m
[32m+[m[32m                    stop_flag.store(true, Ordering::SeqCst);[m
[32m+[m[41m                    [m
                     if let Ok(best_move_result) = game_manager_clone[m
                         .send(game_manager::handler_game::GetBestMove)[m
                         .await[m
[36m@@ -312,6 +320,8 @@[m [mimpl Handler<TimeoutCheck> for EngineDispatcher {[m
     }[m
 }[m
 [m
[32m+[m
[32m+[m
 #[derive(Debug, Message)][m
 #[rtype(result = "()")][m
 pub struct EngineInitTimeLimit {[m
[36m@@ -414,7 +424,9 @@[m [mimpl Handler<EngineInterrupt> for EngineDispatcher {[m
     type Result = ();[m
 [m
     fn handle(&mut self, _msg: EngineInterrupt, _ctx: &mut Self::Context) -> Self::Result {[m
[32m+[m[32m        tracing::debug!("Receive EngineInterrupt");[m
         if let Ok(mut engine) = self.engine.lock() {[m
[32m+[m[32m            tracing::debug!("Stop engine");[m
             engine.stop();[m
         } else {[m
             // Handle the case where the lock cannot be acquired[m
